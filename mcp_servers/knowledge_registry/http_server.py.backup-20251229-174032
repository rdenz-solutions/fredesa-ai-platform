#!/usr/bin/env python3
"""
HTTP/SSE wrapper for FreDeSa Knowledge Registry MCP Server
Implements MCP Specification 2025-03-26 - Streamable HTTP Transport
Exposes MCP tools via JSON-RPC 2.0 for Airia Gateway integration
"""

import os
import json
from typing import Dict, Any
from fastapi import FastAPI, HTTPException, Header, Request, Response
from fastapi.responses import StreamingResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn

# Import database operations (pure PostgreSQL, no MCP SDK)
from db_operations import KnowledgeRegistryDB

app = FastAPI(
    title="FreDeSa Knowledge Registry MCP Server",
    description="1,043 authoritative sources with epistemological framework",
    version="1.0.0"
)

# CORS for Airia Gateway
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Airia Gateway domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize database connection
db = KnowledgeRegistryDB()

# Request models
class QueryRequest(BaseModel):
    query: str
    dimension: str = None
    category: str = None
    min_authority: int = 50
    max_results: int = 10

class SourceDetailsRequest(BaseModel):
    source_id: str

# Health check
@app.get("/health")
async def health_check():
    """Health check endpoint."""
    try:
        # Test database connection
        conn = db.get_connection()
        cur = conn.cursor()
        cur.execute("SELECT 1")
        cur.close()
        conn.close()
        return {"status": "healthy", "database": "connected"}
    except Exception as e:
        return JSONResponse(
            status_code=503,
            content={"status": "unhealthy", "error": str(e)}
        )

# ============================================
# MCP Streamable HTTP Transport (JSON-RPC 2.0)
# Per MCP Specification 2025-03-26
# ============================================

@app.post("/mcp/sse")
@app.post("/mcp")
async def mcp_endpoint(request: Request):
    """
    MCP Streamable HTTP endpoint.
    Handles JSON-RPC 2.0 messages: initialize, tools/list, tools/call
    This is what Airia's Custom MCP Server connects to.
    """
    try:
        body = await request.json()
        method = body.get("method")
        params = body.get("params", {})
        request_id = body.get("id")
        
        if method == "initialize":
            # Return server capabilities per MCP spec
            return JSONResponse(content={
                "jsonrpc": "2.0",
                "id": request_id,
                "result": {
                    "protocolVersion": "2024-11-05",
                    "capabilities": {
                        "tools": {}
                    },
                    "serverInfo": {
                        "name": "fredesa-knowledge-registry",
                        "version": "1.0.0"
                    }
                }
            })
        
        elif method == "tools/list":
            # Return available tools with JSON Schema (MCP format)
            return JSONResponse(content={
                "jsonrpc": "2.0",
                "id": request_id,
                "result": {
                    "tools": [
                        {
                            "name": "query_knowledge_base",
                            "description": "Search 1,043 authoritative federal contracting sources with epistemological filtering. Returns sources with authority scores (90=official, 70=expert, 50=community).",
                            "inputSchema": {
                                "type": "object",
                                "properties": {
                                    "query": {
                                        "type": "string",
                                        "description": "Search query (e.g., 'FAR Part 15', 'DFARS cybersecurity')"
                                    },
                                    "dimension": {
                                        "type": "string",
                                        "enum": ["theory", "practice", "history", "current", "future"],
                                        "description": "Epistemological dimension to filter by"
                                    },
                                    "category": {
                                        "type": "string",
                                        "description": "Knowledge category (e.g., 'Federal_Contracting', 'Cybersecurity')"
                                    },
                                    "min_authority": {
                                        "type": "integer",
                                        "minimum": 50,
                                        "maximum": 90,
                                        "default": 50,
                                        "description": "Minimum authority score (50-90)"
                                    },
                                    "max_results": {
                                        "type": "integer",
                                        "minimum": 1,
                                        "maximum": 15,
                                        "default": 10,
                                        "description": "Maximum results to return"
                                    }
                                },
                                "required": ["query"]
                            }
                        },
                        {
                            "name": "get_source_details",
                            "description": "Get full metadata for a specific knowledge source by UUID.",
                            "inputSchema": {
                                "type": "object",
                                "properties": {
                                    "source_id": {
                                        "type": "string",
                                        "description": "UUID of the source"
                                    }
                                },
                                "required": ["source_id"]
                            }
                        },
                        {
                            "name": "list_categories",
                            "description": "List all available knowledge categories with source counts.",
                            "inputSchema": {
                                "type": "object",
                                "properties": {}
                            }
                        }
                    ]
                }
            })
        
        elif method == "tools/call":
            # Execute tool and return result
            tool_name = params.get("name")
            arguments = params.get("arguments", {})
            
            try:
                if tool_name == "query_knowledge_base":
                    result = db.query_knowledge_base(**arguments)
                elif tool_name == "get_source_details":
                    result = db.get_source_details(**arguments)
                elif tool_name == "list_categories":
                    result = db.list_categories()
                else:
                    return JSONResponse(content={
                        "jsonrpc": "2.0",
                        "id": request_id,
                        "error": {
                            "code": -32601,
                            "message": f"Unknown tool: {tool_name}"
                        }
                    }, status_code=400)
                
                return JSONResponse(content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "result": {
                        "content": [
                            {
                                "type": "text",
                                "text": json.dumps(result, indent=2, default=str)
                            }
                        ]
                    }
                })
                
            except Exception as e:
                return JSONResponse(content={
                    "jsonrpc": "2.0",
                    "id": request_id,
                    "error": {
                        "code": -32603,
                        "message": str(e)
                    }
                }, status_code=500)
        
        elif method == "notifications/initialized":
            # Client acknowledgment - return 202 Accepted per spec
            return Response(status_code=202)
        
        else:
            return JSONResponse(content={
                "jsonrpc": "2.0",
                "id": request_id,
                "error": {
                    "code": -32601,
                    "message": f"Method not found: {method}"
                }
            }, status_code=400)
            
    except json.JSONDecodeError:
        return JSONResponse(content={
            "jsonrpc": "2.0",
            "id": None,
            "error": {
                "code": -32700,
                "message": "Parse error"
            }
        }, status_code=400)
    except Exception as e:
        return JSONResponse(content={
            "jsonrpc": "2.0",
            "id": None,
            "error": {
                "code": -32603,
                "message": str(e)
            }
        }, status_code=500)

# ============================================
# Legacy REST API endpoints (for direct access)
# ============================================

@app.get("/tools")
async def list_tools():
    """List available MCP tools (REST format)."""
    return {
        "tools": [
            {
                "name": "query_knowledge_base",
                "description": "Search 1,043 authoritative sources with epistemological filtering",
                "parameters": {
                    "query": "string (required)",
                    "dimension": "string (optional): theory/practice/history/current/future",
                    "category": "string (optional): Federal_Contracting, Cybersecurity, etc.",
                    "min_authority": "integer (50-90, default: 50)",
                    "max_results": "integer (1-15, default: 10)"
                }
            },
            {
                "name": "get_source_details",
                "description": "Get full metadata for a specific source",
                "parameters": {
                    "source_id": "string (required): UUID of the source"
                }
            },
            {
                "name": "list_categories",
                "description": "List all available knowledge categories",
                "parameters": {}
            }
        ]
    }

@app.post("/tools/query_knowledge_base")
async def query_knowledge_base(request: QueryRequest):
    """Query the knowledge base (REST endpoint)."""
    try:
        result = db.query_knowledge_base(
            query=request.query,
            dimension=request.dimension,
            category=request.category,
            min_authority=request.min_authority,
            max_results=request.max_results
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/tools/get_source_details")
async def get_source_details(request: SourceDetailsRequest):
    """Get source details (REST endpoint)."""
    try:
        result = db.get_source_details(request.source_id)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/tools/list_categories")
async def list_categories():
    """List all categories (REST endpoint)."""
    try:
        result = db.list_categories()
        return {"categories": result}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# ============================================
# SSE endpoint for backwards compatibility
# ============================================

@app.get("/mcp/sse")
async def mcp_sse_get(authorization: str = Header(None)):
    """
    Server-Sent Events GET endpoint.
    Per MCP spec, GET can be used for server-to-client messages.
    """
    async def event_generator():
        # Send initial connection event
        yield f"data: {json.dumps({'type': 'connected', 'server': 'fredesa-knowledge-registry'})}\n\n"
        
        # Keep connection alive
        while True:
            import asyncio
            await asyncio.sleep(30)
            yield f"data: {json.dumps({'type': 'ping'})}\n\n"
    
    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        }
    )

# Stats endpoint
@app.get("/stats")
async def get_stats():
    """Get knowledge base statistics."""
    try:
        conn = db.get_connection()
        cur = conn.cursor()
        
        # Get total sources
        cur.execute("SELECT COUNT(*) FROM sources")
        total_sources = cur.fetchone()[0]
        
        # Get by authority
        cur.execute("""
            SELECT authority_score, COUNT(*) 
            FROM sources 
            GROUP BY authority_score 
            ORDER BY authority_score DESC
        """)
        authority_breakdown = {row[0]: row[1] for row in cur.fetchall()}
        
        # Get by dimension
        cur.execute("""
            SELECT epistemological_dimension, COUNT(*) 
            FROM sources 
            GROUP BY epistemological_dimension
        """)
        dimension_breakdown = {row[0]: row[1] for row in cur.fetchall()}
        
        cur.close()
        conn.close()
        
        return {
            "total_sources": total_sources,
            "authority_breakdown": authority_breakdown,
            "dimension_breakdown": dimension_breakdown,
            "categories": len(db.list_categories())
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    port = int(os.getenv("PORT", 8001))
    uvicorn.run(app, host="0.0.0.0", port=port)
